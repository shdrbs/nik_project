사용한 툴 : 전자정부3.9
빌드 툴 : 메이븐
DBMS : Oracle11g
DB연결 : hikariCP 사용
	MyBatis를 사용해서 sql문을 따로 작성함.
log : log4jdbc-log4j2-jdbc4를 사용해서 로그문의 가독성을 높힘.
단위 테스트 : junit4 사용
---------------------------------------------------------------------------------------------------------------------------
jdbc와 hikariCP연결을 확인하기 위해 테스트 클래스작성함
-com.nik.project.db
    JDBCTest.java
    DataSourceTest.java
---------------------------------------------------------------------------------------------------------------------------
<view 구성>
main 페이지
	-gnb area
		(괸리자 페이지, 로그아웃, 마이룸, 장바구니, 고객센터)링크
	-logo 이미지
	-search area
	-login area
		로그인 할 경우 회원이름, 충전금액, 포인트가 보이게 설정
	-navi area
	-content area

관리자 페이지
	-header
		(메인 페이지, 로그아웃, 고객센터)링크
	-main
		(상품등록, 상품관리, 회원관리, 주문 현황)페이지
	-footer
		(회사소개, 이용약관, 고객센터, 광고문의)
		logo이미지
		간단한 쇼핑몰 정보
--------------------------------------------------------------------------------------------------------------------------
<작업 순서>
1. 메인 페이지 제작
2. 메인 페이지 Controller 설정
3. 로그인,회원가입 페이지 제작
4. 로그인,회원가입 페이지 Controller 설정

회원가입 기능 구현
1. 데이터베이스 테이블 생성 및 VO 생성
2. MemberMapper.xml 추가 (memberJoin insert문 작성)
3. MemberDAO 추가
4. Mapper에 추가한 쿼리문 테스트(MemberMapperTests.java)
5. MemberService 추가
6. MemberController 회원가입 메서드 추가
7. join.jsp 회원가입 기능 버튼 구현

아이디 중복 검사
1. <span>태그 추가(+css)
2. 아이디 중복검사 메서드 작성 및 테스트(자바스크립트)
3. ajax 작성
4. controller 작성
5. mapper / dao / service 작성

인증번호 이메일 전송
1. 이메일 전송 환경 세팅
2. 인증번호 입력란 색상 변경 및 disabled 속성 추가
3. 이메일 전송 메서드 추가(자바스크립트)
4. Controller 메서드 추가
5. 인증번호(난수) 생성
6. 인증번호 이메일 전송
7. 인증번호 뷰(회원가입 페이지)로 전송
8. 인증번호 입력란 변환 기능
9. 인증번호 일치여부 검사 기능

다음 주소록 api 연동
1. 외부 스크립트 연결 코드 추가
2. 주소 검색 기능 메서드 추가(자바스크립트)
3. 주소 입력 <input>태그 수정(readonly)

회원가입 유효성 검사
1. 유효성 검사 통과 유무 변수 선언
2. 입력값 변수 선언
3. span 태그 추가(경고 메시지)
	-아이디 유효성 검사
		1. 아이디 유효성 검사
		2. 아이디 중복검사 유효성 검사
	-비밀번호 유효성 검사
		1. 비밀번호 유효성 검사
		2. 비밀번호 확인 입력 검사
		3. 비밀번호 확인 일치 검사
	-이름 유효성 검사
		1. 이름 유효성 검사
	-이메일 유효성 검사
		1. 이메일 유효성 검사
		2. 인증번호 유효성 검사
	-주소 유효성 검사
		1. 주소 유효성 검사
		2. 최종 유효성 검사 및 전송

이메일 형식 유효성 검사
1. span 태그 추가
2. 이메일 형식 검사 메서드
3. 메서드 적용(자바스크립트)

로그인 기능 구현
1. Mapper 작성
2. MemberDAO 작성
3. mapper 로그인 메서드 테스트
4. MemberService 인터페이스, 클래스 작성
5. 로그인 페이지(login.jsp) 아이디, 비번 전송
6. MemberController 작성
7. login.jsp 수정(로그인 성공,실패)

비밀번호 인코딩(암호화)
1. BCryptPasswordEncoder 기본 설정
   1.1 pom.xml 추가
   1.2 security-context.xml 생성 및 수정
   1.3 web.xml 수정
2. 회원가입 메서드 수정(MemberController.java)
3. 회원가입 테스트(db에 암호화된 비밀번호 저장)
4. 로그인 메서드 수정(MemberController.java)

로그아웃 기능 구현
1. 로그아웃 버튼 작성(main.jsp)
2. 로그아웃 메서드 작성(MemberController.java)

gnb영역(관리자, 로그인, 비로그인) 구현
0. 관리자 계정 생성
1. gnb_area(main.jsp)수정
2. 로그인 O,X 메뉴
3. 관리자 페이지 메뉴
4. AdminController 작성

인터셉터 적용
1. Interceptor 기본 설정
2. LoginInterceptor.java 구현
3. AdminInterceptor.java 구현
4. 테스트

관리자 페이지(상품등록, 상품관리)페이지
1. views/admin/main.jsp 작성
2. 상품등록(productRegist.jsp)작성
3. 상품관리(productManage.jsp)작성
4. AdminController 추가
	4.1 productRegist 메서드 추가
	4.2 productManage 메서드 추가

상품 등록 페이지
1. 상품 테이블 생성(product)
2. 카테고리 테이블 생성(cate)
3. VO생성
	3.1 ProductVO 작성
	3.2 Criteria 작성(현재 페이지 번호, 페이지 표시 개수, 검색 타입, 검색 키워드 등..)
2. AdminMapper 추가(insert문 productRegist)
3. dao / Service 추가
4. AdminController 수정(productRegist 메서드)
5. 위지윅 적용
6. 달력 위젯 적용
7. 카테고리 리스트 구현
	7.1 CateVO 작성
	7.2 JSON 데이터 변환
	7.3<select>, <option>태그 추가
	7.4 JSON 데이터 javascript 객체로 변환
	7.5 자바스크립트 메서드 작성(대분류, 중분류, 소분류)

상품 등록 유효성 검사
1. <span>태그 추가(경고 메시지)
2. 변수 선언
3. 각 항목 확인
4. 최종 확인

상품 등록(입력란 수정&외래키 설정)
1. <span>태그 추가
2. 할인가격 출력
3. 할인율 유효성 체크 수정
4. 외래 키 추가

상품 목록 기능 구현
1. AdminMapper 작성(productGetList, productGetTotal)
2. dao / Service 메서드
3. AdminController 수정(productManage)
4. view 수정(productManage)

상품 조회 기능 구현
1. AdminMapper 작성(productGetDetail)
2. dao / Service
3. AdminController 작성(productGetInfo)
4. view 처리

---------------------------------------------------------------------------------------------------------------------------
<backend>
메인 페이지
    -Controller는 홈페이지에서 기본적인 기능들(메인페이지 이동, 상품 검색 등)의 요청을 관리하도록 함
로그인 페이지
회원가입 페이지
	1.회원가입 기능 구현을 위해서 member테이블 생성
		CREATE TABLE MEMBER(
		  memberId VARCHAR2(50),
		  memberPw VARCHAR2(100) NOT NULL,
		  memberName VARCHAR2(30) NOT NULL,
		  memberMail VARCHAR2(100) NOT NULL,
		  memberAddr1 VARCHAR2(100) NOT NULL,
		  memberAddr2 VARCHAR2(100) NOT NULL,
		  memberAddr3 VARCHAR2(100) NOT NULL,
		  adminCk NUMBER NOT NULL,
		  regDate DATE NOT NULL,
		  money number NOT NULL,
		  point number NOT NULL,
		  PRIMARY KEY(memberId)
		);
	2.MemberVO 생성
	3.MemberMapper 생성
		-회원가입 버튼 클릭 시 DB에 회원정보를 저장하기 위해 MemberMapper에 insert문 작성
	4.MemberDAO 생성
	5.MemberService 인터페이스 생성
	6.sql문이 제대로 작성 됐는지 확인하기 위해 junit테스트 실행(MemberMapperTest.java)
	7.MemberServiceImpl 생성
	8.MemberController 생성
		-회원가입 성공 시 메인페이지로 이동되게 redirect함
	9.회원가입 버튼 기능 구현을 위해 스크립트문 작성

아이디 중복검사
	1.회원가입 시 아이디 중복검사를 위해 span테그 추가
		<span class="id_input_re_1">사용 가능한 아이디입니다.</span>
		<span class="id_input_re_2">아이디가 이미 존재합니다.</span>
	2.아이디 중복검사를 위해 스크립트문 작성
		-아이디를 입력하면 그 값이 post방식으로 /member/memberIdChk url매핑된 컨트롤러로 넘긴다
	3.Controller 작성
		-컨트롤러에서 if문을 거쳐 "fail" 또는 "success"가 view로 넘겨진다
		@RequestMapping(value = "/memberIdChk", method = RequestMethod.POST)
		@ResponseBody
		public String memberIdChkPOST(String memberId) throws Exception{

			log.info("memberIdChk() 진입");

			int result = memberservice.idCheck(memberId);

			log.info("결과값 = " + result);

			if(result != 0) {

				return "fail";	// 중복 아이디가 존재

			} else {

				return "success";	// 중복 아이디 x

			}

		} //
	4.mapper 작성
		-아이디가 존재할 경우 1을 없을 경우 0을 반환 받는다
		<select id="idCheck" resultType="int">
			select count(*) from member where memberId = #{memberId}
		</select>
	5.service 인터페이스 작성
		public int idCheck(String memberId);
	6.service 구현
		@Override
		public int idCheck(String memberId) {
			return memberDao.idCheck(memberId);
		}
	7.MemberDAO 작성
		public int idCheck(String memberId) {
			return sqlSession.selectOne("com.nik.project.mapper.MemberMapper.idCheck", memberId);
		}
	8.아이디 중복점검 쿼리문이 제대로 작동되는지 테스트
		@Test
		public void memberIdChk() throws Exception{
			String id = "admin23";	// 존재하는 아이디
			String id2 = "test123";	// 존재하지 않는 아이디
			memberdao.idCheck(id);
			memberdao.idCheck(id2);
		}

이메일 인증번호 전송
	-smtp 사용을 위해 구글설정->보안->보안 수준이 낮은 앱의 액세스 사용함으로 변경
	-pom.xml 의존성 주입 추가
		<dependency>
			<groupId>javax.mail</groupId>
			<artifactId>mail</artifactId>
			<version>1.4.7</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context-support</artifactId>
			<version>${org.springframework-version}</version>
		</dependency>
	-root-context.xml에 mailSender Bean 등록
	1.인증번호 발송을 위해 스크립트문 추가
		-url을 통해 데이터를 보낼 수 있도록 get방식으로 처리함
		-인증번호 전송 버튼 클릭 시 disabled를 false로 바꿔서 입력가능하게 함
		$(".mail_check_button").click(function(){

		var email = $(".mail_input").val();        // 입력한 이메일
		var cehckBox = $(".mail_check_input");     // 인증번호 입력란
		var boxWrap = $(".mail_check_input_box");  // 인증번호 입력란 박스

		$.ajax({

			type:"GET",
			url:"mailCheck?email=" + email,
			success:function(data){

				cehckBox.attr("disabled",false);
				boxWrap.attr("id", "mail_check_input_box_true");
				code = data;

			}

		});

	});
	2.컨트롤러 작성
		-view에서 데이터가 넘어오면 6자리 인증번호생성
		-이메일 전송에 필요한 데이터 작성
		-ajax를 통한 요청으로 인해 뷰로 다시 반환할 때 데이터 타입은 String 타입만 가능하기 때문에 String 타입으로 변환 후 반환
		@RequestMapping(value="/mailCheck", method=RequestMethod.GET)
		@ResponseBody
		public String mailCheckGET(String email) throws Exception{

			/* 뷰(View)로부터 넘어온 데이터 확인 */
			log.info("이메일 데이터 전송 확인");
			log.info("인증번호 : " + email);

			/* 인증번호(난수) 생성 */
			Random random = new Random();
			/* 111111 ~ 999999 범위의 숫자를 얻기 위해서 */
			int checkNum = random.nextInt(888888) + 111111;
			log.info("인증번호 " + checkNum);

			/* 이메일 보내기 */
			String setFrom = "wntmxld55@gmail.com";
			String toMail = email;
			String title = "회원가입 인증 이메일 입니다.";
			String content =
					"홈페이지를 방문해주셔서 감사합니다." +
					"<br><br>" +
					"인증 번호는 " + checkNum + "입니다." +
					"<br>" +
					"해당 인증번호를 인증번호 확인란에 기입하여 주세요.";

			try {

				MimeMessage message = mailSender.createMimeMessage();
				MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");
				helper.setFrom(setFrom);
				helper.setTo(toMail);
				helper.setSubject(title);
				helper.setText(content,true);
				mailSender.send(message);

			}catch(Exception e) {
				e.printStackTrace();
			}

			String num = Integer.toString(checkNum);

			return num;
		}

인증번호 일치 여부 검사
	-컨트롤러로부터 전달받은 인증번호를 뷰에 저장하는 코드를 추가, 사용자가 입력한 인증번호와 비교할 수 있도록 하기 위함
	-스크립트 문 제일 상단에 code 변수를 선언
		var code = "";
	-인증번호 이메일 전송 메서드 내의 ajax success 코드에 컨트롤러로부터 전달받은 인증번호를 위에서 선언한 code에 저장시키는 코드를 추가
		code = data;
	-인증번호 비교를 위한 메서드 추가
		$(".mail_check_input").blur(function(){

			var inputCode = $(".mail_check_input").val();        // 입력코드
			var checkResult = $("#mail_check_input_box_warn");   // 비교 결과

			if(inputCode == code){                               // 일치할 경우
				checkResult.html("인증번호가 일치합니다.");
				checkResult.attr("class", "correct");
				mailnumCheck = true;
			} else {                                             // 일치하지 않을 경우
				checkResult.html("인증번호를 다시 확인해주세요.");
				checkResult.attr("class", "incorrect");
				mailnumCheck = false;
			}

		});
	-일치할 경우(inpuCode == checkCode) span태그에 "인증번호가 입치합니다."라는 문구와 class속성이 correct(초록색)로 변경
	-불일치할 경우(inpuCode!= checkCode) span태그에 "인증번호를 다시 확인해주세요."라는 문구와 class속성이 incorrect(빨간색)로 변경

다음 주소록 api 사용
	-주소 입력 필드를 사용자가 임의로 고칠 수 없게 readonly 속성을 준다
		<input class="address_input_1" name="memberAddr1" readonly="readonly">
		<input class="address_input_2" name="memberAddr2" readonly="readonly">
		<input class="address_input_3" name="memberAddr3" readonly="readonly">
	-다음 주소록 api사용을 위해 스크립트문 작성
		<script src="https://t1.daumcdn.net/mapjsapi/bundle/postcode/prod/postcode.v2.js"></script>
	-주소록 api 기능을 위해 메서드 작성
		function daum_address(){

			new daum.Postcode({
				oncomplete: function(data) {
					// 팝업에서 검색결과 항목을 클릭했을때 실행할 코드를 작성하는 부분입니다.
					// 각 주소의 노출 규칙에 따라 주소를 조합한다.
					// 내려오는 변수가 값이 없는 경우엔 공백('')값을 가지므로, 이를 참고하여 분기 한다.
					var addr = ''; // 주소 변수
					var extraAddr = ''; // 참고항목 변수

					//사용자가 선택한 주소 타입에 따라 해당 주소 값을 가져온다.
					if (data.userSelectedType === 'R') { // 사용자가 도로명 주소를 선택했을 경우
						addr = data.roadAddress;
					} else { // 사용자가 지번 주소를 선택했을 경우(J)
						addr = data.jibunAddress;
					}

					// 사용자가 선택한 주소가 도로명 타입일때 참고항목을 조합한다.
					if(data.userSelectedType === 'R'){
						// 법정동명이 있을 경우 추가한다. (법정리는 제외)
						// 법정동의 경우 마지막 문자가 "동/로/가"로 끝난다.
						if(data.bname !== '' && /[동|로|가]$/g.test(data.bname)){
							extraAddr += data.bname;
						}
						// 건물명이 있고, 공동주택일 경우 추가한다.
						if(data.buildingName !== '' && data.apartment === 'Y'){
							extraAddr += (extraAddr !== '' ? ', ' + data.buildingName : data.buildingName);
						}
						// 표시할 참고항목이 있을 경우, 괄호까지 추가한 최종 문자열을 만든다.
						if(extraAddr !== ''){
							extraAddr = ' (' + extraAddr + ')';
						}
						// 조합된 참고항목을 해당 필드에 넣는다.
						// document.getElementById("sample6_extraAddress").value = extraAddr;

						// 주소변수 문자열과 참고항목 문자열 합치기
						addr += extraAddr;

					} else {
						// document.getElementById("sample6_extraAddress").value = '';
						addr += ' ';
					}

					// 우편번호와 주소 정보를 해당 필드에 넣는다.
					$(".address_input_1").val(data.zonecode);
					$(".address_input_2").val(addr);

				}
			}).open();

		}
	-상세주소 필드를 사용자가 변경할 수 있게 코드 추가
		$(".address_input_3").attr("readonly",false);
		$(".address_input_3").focus();

회원가입 유효성 검사
	-회원가입 시 정보를 입력하지 않거나 잘못 입력한 경우를 점검해서 성공하면 true를 실패하면 false를 반환
	-유효성 점검 통과유무 확인을 위해 변수 작성
		var idCheck = false;            // 아이디
		var idckCheck = false;          // 아이디 중복 검사
		var pwCheck = false;            // 비번
		var pwckCheck = false;          // 비번 확인
		var pwckcorCheck = false;       // 비번 확인 일치 확인
		var nameCheck = false;          // 이름
		var mailCheck = false;          // 이메일
		var mailnumCheck = false;       // 이메일 인증번호 확인
		var addressCheck = false        // 주소
	-각 항목에 입력된 값을 사용하기 위해 변수를 선언하여 각 항목의 입력값으로 초기화하고 해당 변수들은 회원가입 버튼 작동 메서드 내부에 선언
		var id = $('.id_input').val();              // id 입력란
        var pw = $('.pw_input').val();              // 비밀번호 입력란
        var pwck = $('.pwck_input').val();          // 비밀번호 확인 입력란
        var name = $('.user_input').val();          // 이름 입력란
        var mail = $('.mail_input').val();          // 이메일 입력란
        var addr = $('.address_input_3').val();     // 주소 입력란
	-각 항목 입력란이 공백이거나 잘못 입력하고 가입하기 버튼을 클릭 시 경고글 역할을 위해 span테크 추가
	 추가한 span테그들은 안보이도록 css속성에 display: none;속성 부여
		<span class="final_id_ck">아이디를 입력해주세요.</span>
		<span class="final_pw_ck">비밀번호를 입력해주세요.</span>
		<span class="final_pwck_ck">비밀번호 확인을 입력해주세요.</span>
		<span class="final_name_ck">이름을 입력해주세요.</span>
		<span class="final_mail_ck">이메일을 입력해주세요.</span>
		<span class="final_addr_ck">주소를 입력해주세요.</span>

비밀번호 확인 일치 여부
	-비밀번호 필드와 비밀번호 확인 필드의 입력 값 일치,불일치 여부를 위해 span테그 추가
		<span class="pwck_input_re_1">비밀번호가 일치합니다.</span>
		<span class="pwck_input_re_2">비밀번호가 일치하지 않습니다.</span>
	-비밀번호 확인 일치 유효성 검사 메서드 추가
		$('.pwck_input').on("propertychange change keyup paste input", function(){

			var pw = $('.pw_input').val();
			var pwck = $('.pwck_input').val();
			$('.final_pwck_ck').css('display', 'none');

			if(pw == pwck){
				$('.pwck_input_re_1').css('display','block');
				$('.pwck_input_re_2').css('display','none');
				pwckcorCheck = true;
			}else{
				$('.pwck_input_re_1').css('display','none');
				$('.pwck_input_re_2').css('display','block');
				pwckcorCheck = false;
			}

		});

이메일 형식 유형성 검사
	-이메일 형식 검사를 위해 메서드 작성
	-정규식을 사용해서 이메일 형식 검사를 함
		function mailFormCheck(email){

			var form = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i;

			return form.test(email);

		}

	-이메일을 입력하고 인증번호 전송 버튼을 누르면 이메일 형식 검사가 되도록 인증번호 전송을 위해 작성한 메서드에
	 코드 추가
		if(mailFormCheck(email)){
			warnMsg.html("이메일이 전송 되었습니다. 이메일을 확인해주세요.");
			warnMsg.css("display", "inline-block");
		} else {
			warnMsg.html("올바르지 못한 이메일 형식입니다.");
			warnMsg.css("display", "inline-block");
			return false;
		}

로그인 기능 구현
	-mapper 작성 : 아이디와 비밀번호를 db에 저장된 값과 비교해서 성공 시 아이디,이름,돈,포인트 등을 반환해서 상단에 회원정보 표시
		<select id="memberLogin" resultType="com.nik.project.entity.MemberVO">
			select memberId, memberName, adminck, money, point from member where memberId = #{memberId} and memberPw = #{memberPw}
		</select>
	-dao 작성
		public MemberVO memberLogin(MemberVO member) {
			return sqlSession.selectOne("com.nik.project.mapper.MemberMapper.memberLogin", member);
		}
	-Service, ServiceImpl 작성
		public MemberVO memberLogin(MemberVO member) {
			return memberDao.memberLogin(member);
		}
	-sql문이 제대로 작동하는지 확인하기 위해 test문 작성
		@Test
		public void memberLogin() throws Exception{

			MemberVO member = new MemberVO();    // MemberVO 변수 선언 및 초기화

			/* 올바른 아이디 비번 입력경우 */
			//member.setMemberId("admin23");
			//member.setMemberPw("admin");

			/* 올바른 않은 아이디 비번 입력경우 */
			member.setMemberId("test1123");
			member.setMemberPw("test1321321");

			memberdao.memberLogin(member);
			System.out.println("결과 값 : " + memberdao.memberLogin(member));

		}
	-Controller 작성
	 MemberVO는 데이터를 전달받기 위해, Model은 로그인 성공 시 model에 회원 정보를 저장하기 위해,
	 RedirectAttributes는 로그인 실패 시 리다이렉트 된 로그인 페이지에 실패를 의미하는 데이터를 전송하기 위해 사용
		@PostMapping("login")
		public String memberLogin(Model model, MemberVO member, RedirectAttributes rttr) {

			log.info("login 메서드 진입");
			log.info("전달된 데이터 : {}" + member);

			MemberVO memberVO = memberservice.memberLogin(member);

			if(memberVO == null) { // 일치하지 않는 아이디, 비밀번호 입력 경우

				int result = 0;
				rttr.addFlashAttribute("result", result);
				return "redirect:/member/login";

			}

			model.addAttribute("member", memberVO); // 일치하는 아이디, 비밀번호 경우 (로그인 성공)

			return "redirect:/";
		}
	-아이디와 비밀번호 틀릴 경우 경고문 작성
		<c:if test="${result == 0 }">
			<div class="login_warn">사용자 아이디 또는 비밀번호를 잘못 입력하셨습니다.</div>
		</c:if>
	-로그인 시 회원가입 버튼과 로그인 버튼이 안보이게 하고 로그인한 회원의 정보가 보이도록 코드 수정
		<!-- 로그인 하지 않은 상태 -->
		<c:if test = "${member == null }">
			<div class="login_button"><a href="/member/login">로그인</a></div>
			<span><a href="/member/join">회원가입</a></span>
		</c:if>

		<!-- 로그인한 상태 -->
		<c:if test="${member != null }">
			<div class="login_success_area">
				<span>회원 : ${member.memberName}</span>
				<span>충전금액 : ${member.money}</span>
				<span>포인트 : ${member.point}</span>
			</div>
		</c:if>

비밀번호 암호화
	-비밀번호 암호화를 위해 회원가입 Controller 코드를 수정
		String rawPw = "";           // 인코딩 전 비밀번호
        String encodePw = "";        // 인코딩 후 비밀번호

        rawPw = member.getMemberPw();            // 비밀번호 데이터 얻음
        encodePw = pwEncoder.encode(rawPw);      // 비밀번호 인코딩
        member.setMemberPw(encodePw);            // 인코딩된 비밀번호 member객체에 다시 저장

        /* 회원가입 쿼리 실행 */
        memberservice.memberJoin(member);
	-암호화된 비밀번호와 사용자가 입력한 비밀번호가 일치하는지 확인을 위해 로그인 컨트롤러 코드 수정
		@PostMapping("login")
		public String memberLogin(HttpSession session, MemberVO member, RedirectAttributes rttr) {

			log.info("login 메서드 진입");
			log.info("전달된 데이터 : {}" + member);

			BCryptPasswordEncoder pwEncoder = new BCryptPasswordEncoder();

			String rawPw = "";
			String encodePw = "";

			MemberVO memberVO = memberservice.memberLogin(member);    // 제출한아이디와 일치하는 아이디 있는지

			if(memberVO != null) {            // 일치하는 아이디 존재시

				rawPw = member.getMemberPw();        // 사용자가 제출한 비밀번호
				encodePw = memberVO.getMemberPw();        // 데이터베이스에 저장한 인코딩된 비밀번호

				if(true == pwEncoder.matches(rawPw, encodePw)) {        // 비밀번호 일치여부 판단

					memberVO.setMemberPw("");                     // 인코딩된 비밀번호 정보 지움
					session.setAttribute("member", memberVO);     // session에 사용자의 정보 저장
					return "redirect:/";        // 메인페이지 이동


				} else {

					rttr.addFlashAttribute("result", 0);
					return "redirect:/member/login";    // 로그인 페이지로 이동
				}

			} else {                    // 일치하는 아이디가 존재하지 않을 시 (로그인 실패)

				rttr.addFlashAttribute("result", 0);
				return "redirect:/member/login";    // 로그인 페이지로 이동
			}

		} //

로그아웃 버튼 기능 구현
	-회원 로그아웃을 위해 main.jsp에 코드 추가
		<a href="/member/logout.do">로그아웃</a>
	-컨트롤러 작성
	 session에 저장된 정보를 삭제후 메인페이지로 이동되게 함
		@GetMapping("logout.do")
		public String logoutMainGET(HttpSession session) throws Exception{

			log.info("logoutMainGET메서드 진입");

			session.invalidate(); // session에 저장된 정보 삭제

			return "redirect:/";
		}

gnb_area 구현
	-비로그인일 경우 로그인,회원가입,고객센터 링크가 보이게 하고
	 로그인일 경우 로그아웃,마이룸,장바구니 링크가 보이게 함
	 admin계정이 로그인 시 관리자 페이지 링크도 보이게 함
		<ul class="list">
			<c:if test="${member == null}">
				<li><a href="/member/login">로그인</a></li>
				<li><a href="/member/join">회원가입</a></li>
			</c:if>
			<!-- gnb : 로그인한 상태 -->
			<c:if test="${member != null }">
				<c:if test="${member.adminCk == 1 }">
					<li><a href="/admin/main">관리자 페이지</a></li>
				</c:if>
				<li>로그아웃</li>
				<li>마이룸</li>
				<li>장바구니</li>
			</c:if>
			<li>고객센터</li>
		</ul>

관리자 페이지 이동 컨트롤러 작성
	@GetMapping("main")
    public void adminMainGET() {

        logger.info("관리자 페이지 이동");

    }

gnb_area 로그아웃 기능 구현
	-비동기 방식으로 로그아웃 하기 위해 ajax 작성
		$("#gnb_logout_button").click(function() {
			//alert("버튼 작동");
			$.ajax({
				type : "POST",
				url : "/member/logout.do",
				success : function(data) {
					//alert("로그아웃 성공");
					document.location.reload();
				}
			}); // ajax
		});
	-컨트롤러 작성
		@PostMapping("logout.do")
		@ResponseBody
		public void logoutPOST(HttpSession session) {

			log.info("gnb 로그아웃 메서드 진입");

			session.invalidate();

		}

Interceptor 적용
	-pom.xml에 spring-webmvc 의존성 주입
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${spring-version}</version>
		</dependency>
	-servlet-context.xml에 설정 추가
		<interceptors>
			<interceptor>
				<mapping path="/member/login.do"></mapping>
				<beans:bean class="com.nik.project.interceptor.LoginInterceptor"></beans:bean>
			</interceptor>
			<interceptor>
				<mapping path="/admin/**"></mapping>
				<beans:bean class="com.nik.project.interceptor.AdminInterceptor"></beans:bean>
			</interceptor>
		</interceptors>
	-LoginInterceptor 작성
	 이전 작업 중 세션이 완전히 제거되지 않아 로그인을 위해 새로운 세션을 저장할 때 발생할 수 있는 에러를 방지하기 위해서 로그인 메서드가
	 MemberController에 진입하기 전에 세션을 제거
		public class LoginInterceptor extends HandlerInterceptorAdapter{

		@Override
		public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
				throws Exception {

			System.out.println("LoginInterceptor preHandle 작동");

			HttpSession session = request.getSession();

			session.invalidate(); // session에 저장된 회원정보 제거

			return true;
		}
	}
	-AdminInterceptor 작성
	 혹시나 관리자 페이지 url을 입력 시 관리자계정이 아니면 페이지 접근이 안되도록 함
		public class AdminInterceptor extends HandlerInterceptorAdapter {

		@Override
		public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
				throws Exception {

			HttpSession session = request.getSession();

			MemberVO memberVO = (MemberVO)session.getAttribute("member");
			String errMsg = "";

			if(memberVO == null || memberVO.getAdminCk() == 0) {    // 관리자 계정 아닌 경우

				// 에러 메시지
				errMsg = "접근을 위해서는 먼저 로그인 하셔야 됩니다";

				request.setAttribute("err_msg", errMsg); // 에러메시지를 "err_msg"에 저장
				request.setAttribute("move_path", "/");  // 메인페이지 경로를 "move_path"에 저장

				// 에러 페이지 => 로그인 페이지로 이동
				RequestDispatcher rd = request.getRequestDispatcher("/WEB-INF/views/error/error.jsp");
				rd.forward(request, response);

				return false;

			}

			return true;    // 관리자 계정 로그인 경우(lvo != null && lvo.getAdminCk() == 1)
		}
	}
	-관리자가 아닌 사람이 관리자페이지 접근 시 경고문을 위해 error.jsp 작성
		<script>
			window.onload=function() {

				var msg = "${err_msg}";

				if (msg.trim() != '') {
					alert(msg);
				}

				location.href= "${pageContext.request.contextPath}${move_path}"; // 페이지 이동
			} //
		</script>

footer, footer gnb 작성
	-main.jsp, /admin/main.jsp에 각각 html,css 작성

관리자 페이지(상품등록, 상품관리) 작성
	-productRegist.jsp, productRegist.css 추가
	 productManage.jsp, productManage.css 추가

상품 테이블 생성
	-출시일(publeYear)경우 Date 타입으로 지정. 행 데이터를 삽입할 때 "yyyy-mm-dd"와 같은 형식으로 삽입
	-상품아이디(id)의 경우 자동으로 숫자가 삽입되도록 sequence 사용
	-할인율(discount)은 소수 둘째 자리까지 허용하는 고정 소수점 타입으로 지정
	-상품소개(intro) 경우 위지윅을 활용하여 작성된 데이터를 등록시키려고 함 위지윅을 사용하게 되면
	 태그가 자동으로 삽입되게 되어 길지 않은 길이의 글을 작성하더라도 DB에 등록 시에는 태그를 포함하면 매우 많은 데이터들이 등록되게 됨
	 따라서 대량의 데이터를 등록할 수 있도록 CLOB타입을 사용
	-카테고리 코드(cateCode) 카테고리 리스트 출력 기능을 상품 등록 페이지에 적용한 뒤에 등록
	create table product(
		id number primary key,           -- 상품 아이디
		name varchar2(50)   not null,    -- 상품 이름
		publeYear Date not null,         -- 출시일
		cateCode varchar2(30),           -- 카테고리 코드
		price number not null,           -- 상품 가격
		stock number not null,           -- 상품 재고
		discount number(2,2),            -- 할일율
		intro clob,                      -- 상품 소개
		regDate date default sysdate,    -- 등록 날짜
		updateDate date default sysdate  -- 수정 날짜
	);

카테고리 테이블 생성
	-기본키는 cateCode를 지정
	-cateParent 컬럼에 들어갈 값은 cateCode에 있는 값만 등록할 수 있도록 외래 키 설정
	-카테고리 코드 규칙
	 상품을 3가지 단계로 분류. 1단계 분류는 '남자','여자'의 구분
					   2단계는 '상의', '하의', '신발' 과 같이 큰 범주의 분야로 분류이고,
					   3단계는 2단계의 분류에서 좀 더 세분화된 분야의 범주로 분류
					   이러한 3개의 분류를 가지고 카테고리 코드의 규칙을 아래와 같이 정함
	-위의 '카테고리 코드(cateCode)' 와 더불어 "카테고리 테이블(cate)"에는 '카테고리 이름(cateName)', '상위 카테고리(cateParent)', '카테고리 등급(tier)' 칼럼들로 구성
	-'상위 카테고리(cateParent)'는 어떠한 상위 카테고리의 하위 카테고리인지를 알 수 있는 역할
	-'카테고리 등급(tier)'경우 해당 카테고리 번호가 위에서 분류한 1단계, 2단계, 3단계 중 어떠한 단계인지를 표시
	create table cate(
		tier number(1) not null,
		cateName varchar2(30) not null,
		cateCode varchar2(30) not null,
		cateParent varchar2(30) ,
		primary key(cateCode),
		foreign key(cateParent) references cate(cateCode)
	);

카테고리(cate) 테이블 데이터 삽입
	insert into cate(tier, cateName, cateCode) values (1, '남성', '100000');
		insert into cate(tier, cateName, cateCode, cateParent) values (2, '상의', '101000','100000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '셔츠', '101001','101000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '반팔티', '101002','101000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '후드티', '101003','101000');
		insert into cate(tier, cateName, cateCode, cateParent) values (2, '하의', '102000','100000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '반바지', '102001','102000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '청바지', '102002','102000');
		insert into cate(tier, cateName, cateCode, cateParent) values (2, '신발', '103000','100000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '운동화', '103001','103000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '런닝화', '103002','103000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '샌들', '103003','103000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '구두', '103004','103000');
	insert into cate(tier, cateName, cateCode) values (1, '여성', '200000');
		insert into cate(tier, cateName, cateCode, cateParent) values (2, '상의', '201000','200000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '셔츠', '201001','201000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '반팔티', '201002','201000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '후드티', '201003','201000');
		insert into cate(tier, cateName, cateCode, cateParent) values (2, '하의', '202000','200000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '치마', '202001','202000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '반바지', '202002','202000');
		insert into cate(tier, cateName, cateCode, cateParent) values (2, '신발', '203000','200000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '운동화', '203001','203000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '힐', '203002','203000');
			insert into cate(tier, cateName, cateCode, cateParent) values (3, '샌들', '203003','203000');

ProductVO 생성
	-상품(product)테이블의 데이터를 전달받고 사용하기 위함
	-(상품아이디, 상품이름, 출시일, 카테고리 코드, 카테고리 이름, 상품가격, 상품재고, 할인율, 상품소개, 등록날짜, 수정날짜)를 변수화 시키고,
	 getter, setter, toString 작성

mapper(AdminMapper) 작성
	<insert id="productRegist">
  		insert into product(id, name, publeYear, cateCode, price, stock, discount, intro)
		values(product_seq.NEXTVAL, #{name}, #{publeYear}, #{cateCode}, #{price}, #{stock}, #{discount}, #{intro})
  	</insert>

AdminMapper에 작성한 쿼리 test
	@Test
	public void productRegistTest() throws Exception{

		ProductVO product = new ProductVO();

		product.setName("mapper 테스트");
		product.setPubleYear("2021-03-18");
		product.setCateCode("0231");
		product.setPrice(20000);
		product.setStock(300);
		product.setDiscount(0.23);
		product.setIntro("상품소개");

		mapper.productRegist(product);
	}

service, serviceImpl,DAO 작성
	-com.nik.project.service패키지에
	 AdminService인터페이스 작성
		public void productRegist(ProductVO productVO);
	-AdminServiceImpl클래스 작성
		@Override
		public void productRegist(ProductVO productVO) {

			log.info("(srevice)product........");

			adminDao.productRegist(productVO);

		}
	-com.nik.project.repository패키지에
	 AdminDAO클래스 작성
		public void productRegist(ProductVO productVO) {

			sqlSession.insert("com.nik.project.mapper.AdminMapper.productRegist", productVO);
		}

상품등록 컨트롤러 작성
	@PostMapping("productRegist.do")
	public String productRegist(ProductVO productVO, RedirectAttributes rttr) {

		logger.info("productRegist......" + productVO);

		adminService.productRegist(productVO);

		rttr.addFlashAttribute("regist_result", productVO.getName());

		return "redirect:/admin/productManage";
	}

view 분리화
	-views/admin 경로 안쪽에 있는 jsp파일들을 header, footer를 분리 시키고 include방식으로 결합함

위지윅 적용
	-상품 등록 페이지에서 '상품소개' text_area에 글씨 굵기, 크기조정 등을 사용하기 위해 위지윅 적용함(위지윅 적용하면 text폼 상단에 도구바 생김)
	-위지윅 사용을 위해 스크립트문 추가
		<script src="https://cdn.ckeditor.com/ckeditor5/34.0.0/classic/ckeditor.js"></script>
	-스크립트 작성
		ClassicEditor
			.create(document.querySelector('#intro_textarea'))
			.catch(error=> {
				console.error(error);
			});

달력 위젯(DatePicker) 적용
	-상품 등록 페이지에서 '출시일'입력란을 달력위젯으로 작성되게 하기 위함
    -달력위젯을 적용 시킬 input태그에 속성 추가
     autocomplte경우 input태그를 클릭했을때 이전 데이터가 뜨는 것을 막기 위함
     readony를 추가해준 이유는 datepicker을 통해 삽입된 날짜 데이터를 사용자가 잘못된 형식으로 수정하지 못하도록 하기 위함
    -달력위젯 사용을 위해 스크립트문 추가
	    <link rel="stylesheet" href="//code.jquery.com/ui/1.8.18/themes/base/jquery-ui.css" />
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
		<script src="//code.jquery.com/ui/1.8.18/jquery-ui.min.js"></script>
	-스크립트 작성
		$(function() {
			$( "input[name='publeYear']" ).datepicker();
		});
	-날짜 포맷 방식, 한글화등을 위해 코드 추가
		const config = {
			dateFormat: 'yy-mm-dd', // 날짜 포맷
			showOn : "button",      // 버튼기능 추가
			buttonText:"날짜 선택",   // 버튼 이름 지정

			/* 한글화 */
			prevText: '이전 달',
			nextText: '다음 달',
			monthNames: ['1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월'],
			monthNamesShort: ['1월','2월','3월','4월','5월','6월','7월','8월','9월','10월','11월','12월'],
			dayNames: ['일','월','화','수','목','금','토'],
			dayNamesShort: ['일','월','화','수','목','금','토'],
			dayNamesMin: ['일','월','화','수','목','금','토'],
    		changeYear: true,  // <select>형식으로 변환
			changeMonth: true
		}

카테고리 리스트 구현
	-카테고리 리스트 데이터 객체를 생성하고 객체를 json으로 변환한 후 view로 넘김
	-카테고리 리스트 객체 생성(CateVO), getter,setter,toString
		/* 카테고리 등급 */
		private int tier;
		/* 카테고리 이름 */
		private String cateName;
		/* 카테고리 넘버 */
		private String cateCode;
		/* 상위 카테고리 */
		private String cateParent;
	-DAO 작성(com.nik.project.repository.AdminDAO)
		public List<CateVO> cateList(){
			return sqlSession.selectList("com.nik.project.mapper.AdminMapper.cateList");
		}
	-mapper 작성(com.nik.project.mapper.AdminMapper)
		<select id="cateList" resultType="com.nik.project.model.CateVO">
	  		select * from cate order by catecode
	  	</select>
	-mapper 테스트
		@Test
		public void cateListTest() throws Exception{

			//System.out.println("cateList()..........." + mapper.cateList());
			System.out.println("cateList()..........." + adminDao.cateList());

		}
	-Service 작성(com.nik.project.service.AdminService)
		public List<CateVO> cateList();
	-ServiceImpl 작성(com.nik.project.service.AdminServiceImpl)
		@Override
		public List<CateVO> cateList() {

			log.info("(service)cateList........");

			return adminDao.cateList();
		}
	-Controller 작성(com.nik.project.controller.AdminController)
	 java객체를 JSON형식으로 변환 후 view로 넘기기 위해 model에 값 저장
		@GetMapping("productRegist")
	    public void productRegist(Model model) throws Exception{
	    	logger.info("상품 등록 페이지 접속");

	    	ObjectMapper objm = new ObjectMapper();

	    	List list = adminService.cateList();

	    	String cateList = objm.writeValueAsString(list); // java객체를 String타입의 JSON형식 데이터로 변환

	    	model.addAttribute("cateList", cateList);
	    }
    -view로 넘겨진 json데이터를 사용하기 위해 <select>, <option>태그 추가
    	<div class="cate_wrap">
			<span>대분류</span>
			<select class="cate1">
				<option selected value="none">선택</option>
			</select>
		</div>
		<div class="cate_wrap">
			<span>중분류</span>
			<select class="cate2">
				<option selected value="none">선택</option>
			</select>
		</div>
		<div class="cate_wrap">
			<span>소분류</span>
			<select class="cate3" name="cateCode">
				<option selected value="none">선택</option>
			</select>
		</div>
	-JSON데이터를 javascript가 바로 사용할 수 없기 때문에 JSON데이터를 javascript객체로 변환
		let cateList = JSON.parse('${cateList}'); // JSON데이터를 javascript객체로 변환
	-현재의 cateList객체에는 대분류, 중분류, 소분류가 섞여 있는 상태여서 각 등급에 맞게 분류해서 배열에 저장
	 각 배열에는 'cateName', 'cateCode', 'cateParent' 변수와 그 값을 가지고 있는 객체가 저장하기 위해 9개의 변수 선언
		let cate1Array = new Array(); // 남성, 여성
		let cate2Array = new Array(); // 상의, 하의, 신발
		let cate3Array = new Array(); // 반팔, 셔츠, 바지, 치마 등..
		let cate1Obj = new Object();
		let cate2Obj = new Object();
		let cate3Obj = new Object();

		let cateSelect1 = $(".cate1");
		let cateSelect2 = $(".cate2");
		let cateSelect3 = $(".cate3");
	-for문을 돌려서 tier를 분류하고 각 변수에 저장
		function makeCateArray(obj, array, cateList, tier){
			for(let i = 0; i < cateList.length; i++){
				if(cateList[i].tier === tier){ // 타입비교
					obj = new Object();

					obj.cateName = cateList[i].cateName;
					obj.cateCode = cateList[i].cateCode;
					obj.cateParent = cateList[i].cateParent;

					array.push(obj);

				}
			}
		}
	-각 tier의 배열 초기화
		makeCateArray(cate1Obj,cate1Array,cateList,1);
		makeCateArray(cate2Obj,cate2Array,cateList,2);
		makeCateArray(cate3Obj,cate3Array,cateList,3);

		$(document).ready(function(){
			console.log(cate1Array);
			console.log(cate2Array);
			console.log(cate3Array);
		});
	-<option>태그 구현
	-대분류 <option>태그
	 for문을 돌려서 대분류 출력
	 ex)<option value = "100000">남성</option>
	 	<option value = "200000">여성</option>
			for(let i = 0; i < cate1Array.length; i++){
				cateSelect1.append("<option value='"+cate1Array[i].cateCode+"'>" + cate1Array[i].cateName + "</option>");
			}
	-중분류 <option>태그
	 <option>태그를 지우고 다시 추가하는 이유는 사용자가 대분류를 선택하고 다시 다른 대분류를 선택했을 때 기존의 <option>태그를 없애기 위함
		$(cateSelect1).on("change",function(){ // 대분류(cateSelect1)가 사용(선택)되면 실행

			let selectVal1 = $(this).find("option:selected").val(); // 선택된 대분류의 selected값을 selectVal1에 저장

			cateSelect2.children().remove(); 						 // cateSelect2의 자식요소(<option>태그)를 지운다
			cateSelect2.append("<option value='none'>선택</option>"); // cateSelect2에 다시 <option>태그 추가

			cateSelect3.children().remove();                         // 소분류(cateSelect3)의 자식요소(<option>태그)를 지운다
			cateSelect3.append("<option value='none'>선택</option>"); // 소분류(cateSelect3)에 다시 <option>태그 추가

			for(let i = 0; i < cate2Array.length; i++){
				if(selectVal1 === cate2Array[i].cateParent){
					cateSelect2.append("<option value='"+cate2Array[i].cateCode+"'>" + cate2Array[i].cateName + "</option>");
				}
			}
		});
	-소분류 <option>태그
		$(cateSelect2).on("change",function(){ // 중분류(cateSelect2)가 사용(선택)되면 실행

			let selectVal2 = $(this).find("option:selected").val(); // 선택된 중분류의 selected값을 selectVal2에 저장

			cateSelect3.children().remove();                         // cateSelect3의 자식요소(<option>태그)를 지운다
			cateSelect3.append("<option value='none'>선택</option>");	 // cateSelect3에 다시 <option>태그 추가

			for(let i = 0; i < cate3Array.length; i++){
				if(selectVal2 === cate3Array[i].cateParent){
					cateSelect3.append("<option value='"+cate3Array[i].cateCode+"'>" + cate3Array[i].cateName + "</option>");
				}
			}
		});

상품 등록 유효성 검사
	-상품 등록 페이지에서 공란으로 상품등록 버튼을 클릭 시 경고 메시지가 나오게 함
	 <span>에 경고 메시지를 작성해서 출력

할인율 입력란 인터페이스 & 유효성 검사 변경	& 외래키 설정
	-현재의 할인율 입력란은 소수를 입력 해야 에러가 않나지만 일반의 사용자는 정수를 입력하는 것이 편할 수 있어서 사용자가 입력은 정수를 입력하고
	 서버에 전송할 때는 해당 값을 소수로 변경
	-사용자가 제품 가격과 할인율을 입력하였을 때 할인된 가격이 얼마인지 볼 수 있도록 구현
	-product테이블의 cateCode컬럼이 cate테이블의 cateCode를 참조하도록 외래키 설정

상품 목록 기능 구현
	-Criteria클래스 작성
	-페이징,검색 을 위해 현재 페이지 번호, 보여질 페이지 수, 검색어를 변수화하기 위함
	-현재 페이지,페이지 표시 개수를(1,10)으로 기본값 사용
	-getter,setter,toString 추가
		/* 현재 페이지 번호 */
	    private int pageNum;
	    /* 페이지 표시 개수 */
	    private int amount;
	    /* 스킵 할 게시물 수( (pageNum-1) * amount ) */
	    private int skip;
	    /* 검색 타입 */
	    private String type;
	    /* 검색 키워드 */
	    private String keyword;

	    /* 검색 타입 데이터 배열 변환 */
	    public String[] getTypeArr() {
	        return type == null ? new String[] {} : type.split("");
	    }

	    /* 기본 생성자 -> 기본 세팅 : pageNum = 1, amount = 10 */
	    public Criteria() {
	        this(1,10);
	        this.skip = 0;
	    }

	    /* 생성자 => 원하는 pageNum, 원하는 amount */
	    public Criteria(int pageNum, int amount) {
	        this.pageNum = pageNum;
	        this.amount = amount;
	        this.skip = (pageNum-1)*amount;
	    }
	-pageDTO 작성
		/* 페이지 시작 번호 */
	    private int pageStart;
	    /* 페이지 끝 번호 */
	    private int pageEnd;
	    /* 이전, 다음 버튼 존재 유무 */
	    private boolean next, prev;
	    /* 행 전체 개수 */
	    private int total;
	    /* 현재페이지 번호(pageNum), 행 표시 수(amount), 검색 키워드(keyword), 검색 종류(type) */
	    private Criteria cri;

	    /* 생성자(클래스 호출 시 각 변수 값 초기화) */
	    public PageDTO(Criteria cri, int total) {

	        /* cri, total 초기화 */
	        this.cri = cri;
	        this.total = total;

	        /* 페이지 끝 번호 */
	        this.pageEnd = (int)(Math.ceil(cri.getPageNum()/10.0))*10; // 10,20,30,40,...

	        /* 페이지 시작 번호 */
	        this.pageStart = this.pageEnd - 9; // 1,11,21,31,...

	        /* 전체 마지막 페이지 번호 */
	        int realEnd = (int)(Math.ceil(total*1.0/cri.getAmount())); // 상품 총 수량 * 1.0 / 10

	        /* 페이지 끝 번호 유효성 체크 */
	        if(realEnd < pageEnd) {
	            this.pageEnd = realEnd;
	        }

	        /* 이전 버튼 값 초기화 */
	        this.prev = this.pageStart > 1;

	        /* 다음 버튼 값 초기화 */
	        this.next = this.pageEnd < realEnd;

	    }
	-AdminMapper 작성
	 -rownum을 사용해 페이징 기능을 구현했고, cate테이블을 join문을 사용해 참조해서 카테고리이름을 출력할 수 있게 함
	 -<if>태그를 사용해서 검색키워드가 없으면 where절이 사용안되고 검색키워드가 있으면 where절이 사용됨
	 -최근에 등록된 상품이 제일 처음 보이도록 내림차순 정렬함
		<!-- 상품 리스트 페이징-->
	  	<select id="productGetList" resultType="com.nik.project.model.ProductVO">
		  	select  *
				from(
				    select A.*, rownum as rn
					    from
					    (
					        select id, name, c.cateName, stock, a.regDate
					        from product a
							left outer join cate c
					        on a.cateCode = c.cateCode
					        <if test="keyword != null">
					        	where name like '%' || #{keyword} || '%'
					        </if>
							order by id desc
						) A
					    where rownum &lt;= #{pageNum} * #{amount}
					)where rn &gt; (#{pageNum} -1) * #{amount}

	  	</select>

	  	<!-- 상품 총 갯수 -->
	  	<select id="productGetTotal" resultType="int">
	  		select count(*) from product

	  		<if test="keyword != null">
	  			where name like '%' || #{keyword} || '%'
			</if>
	  	</select>
	-AdminDAO 작성
		// 상품 리스트
		public List<ProductVO> productGetList(Criteria cri) {
			return sqlSession.selectList("com.nik.project.mapper.AdminMapper.productGetList", cri);
		}

		// 상품 총 개수
		public int ProductGetTotal(Criteria cri) {
			return sqlSession.selectOne("com.nik.project.mapper.AdminMapper.productGetTotal", cri);
		}
	-AdminService 작성
		// 상품 리스트
		public List<ProductVO> productGetList(Criteria cri);

		// 상품 총 개수
		public int productGetTotal(Criteria cri);
	-AdminServiceImpl 작성
		// 상품 리스트
		@Override
		public List<ProductVO> productGetList(Criteria cri) {

			log.info("productGetList()...........");

			return adminDao.productGetList(cri);
		}

		// 상품 총 개수
		@Override
		public int productGetTotal(Criteria cri) {

			log.info("productGetTotal()...........");

			return adminDao.ProductGetTotal(cri);
		}
	-AdminController 수정
	 현재 페이지 번호, 검색어 등 매개인자로 받기 위해 Critetia파라미터 추가
		@GetMapping("productManage")
	    public void productManage(Criteria cri, Model model) throws Exception{

	        logger.info("상품 관리 페이지 접속");

	        /* 상품 리스트 데이터 */
			List list = adminService.productGetList(cri);

			if(!list.isEmpty()) {
				model.addAttribute("list", list);
			} else {
				model.addAttribute("listCheck", "empty");
				return;
			}

			/* 페이지 인터페이스 데이터 */
			model.addAttribute("pageMaker", new PageDTO(cri, adminService.productGetTotal(cri)));

			logger.info("pageMaker : {}",new PageDTO(cri, adminService.productGetTotal(cri)));
			logger.info("상품 리스트 : {}", list.get(0));
	    }
	-view 작성
	 상품 목록을 10개씩 나오게 작성, 상품 목록이 10개가 넘어가면 아래쪽에 페이지 넘길 수 있는 버튼 생성

상품 조회 기능 구현
	-상품관리 페이지에서 상품 이름을 클릭 시 상품조회페이지로 이동하기 위함
	-mapper작성
		<select id="productGetDetail" resultType="com.nik.project.model.ProductVO">
			select id, name, publeYear, cateCode, price, stock, discount, intro, regDate, updateDate
			from product where id = #{id}
		</select>
	-dao 작성
		public ProductVO productGetDetail(int id) {
			return sqlSession.selectOne("com.nik.project.mapper.AdminMapper.productGetDetail", id);
		}
	-service, ServiceImpl작성
		@Override
		public ProductVO productGetDetail(int id) {

			log.info("(service)productGetDetail......." + id);

			return adminDao.productGetDetail(id);
		}
	-controller
		@GetMapping({"/productDetail", "/productModify"})
		public void productGetInfo(int id, Criteria cri, Model model) throws JsonProcessingException {

			logger.info("productGetInfo()........." + id);

			ObjectMapper mapper = new ObjectMapper();

			/* 카테고리 리스트 데이터 */
			model.addAttribute("cateList", mapper.writeValueAsString(adminService.cateList()));

			/* 목록 페이지 조건 정보 */
			model.addAttribute("cri", cri);

			/* 조회 페이지 정보 */
			model.addAttribute("productInfo", adminService.productGetDetail(id));
		}












